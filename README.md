# MyChat
<h2>This is clien-server application on TCP portocol!</h2>

<h3>Цель проекта:</h3>
	<p>создат клиент-серверное приложение.</p>
<hr>
<h3>Описание проекта:</h3>
	<p>чат для отправки тескстовых сообщений по модели TCP/IP.</p>
<hr>
<h4>Реализаци проекта:</h4>
	<p>Пользователь запускает клиентскую чать приложения через консоль. Затем ему предлагается утановить соединение с сервером. Он его утанавливает. Сервер принемает этот запрос. Затем клиент отправляет имя того клиента с кем он хочет чатиться. Сервер получает запрос. Сервер свиряет имя другого пользователя в базе данных. Затем есть три варианта развития событий. Первый: сервер не находит в базе данных пользователя и в ответе клиенту сообщает об этом.. Второй: сервер нашел пользователя, который запросил клиент, он об этом сообшает, но серверная часть проекта не может соединить канал с этим пользователем. Третий: сервер нашел того пользователя, который запрашивал клиент, он об этом сообщает, потом он устанавливает соединение, затем клиент отправляет сообщение серверу, он записывает его в лог и отправляет другому пользователю, после чего этот пользователь получает это сообщение и может делать тоже само, что и клиент.</p>
	<hr>
<h4>План реализачии:</h4>
<ol>
	<li>+Для начала нужно наладить связь клиента с сервером. Клиент сможет создать TCP-соединение с клиентом и отправлять сообщения.
	<ul>
		<li>Ввод текста будет через stdin.</li>
	</ul>
	</li>
	<li>+Нужно созадть простой TCP-server, который будет создавть с клиентом канал и принемать сообщения, затем выводить их на экран.</li>
	<li>+Нужно сделать динамический буфер для сообщений, чтобы можно было отправлять сообщения неогранниченной длины.</li>
	<li>+Написать свой протокол для отправки сообщений. Это будет надстройкой над модели TCP\IP.</li>
	<li>+Затем нужно реализовать базу данных клиентов. Она будет представлять собой таблицу с полями id, ip_addr, name.</li> 
	<li>+Сервер при получения соединения будет свирять ip-addres клиента и в ответе вставит его имя.</li>
	<li>Затем нужно, чтобы сервер получал имя того пользователя, с которым клиент хочет поговорить. Также делает, как по выше описанному условию. Но пока сервер будет создавать соединение, а затем сразу его закрывать.</li>
	<li>Клиенту дать возомжность получать запросы от сервера.</li>
	<li>Теперь сервер не будет сразу, закрывать соединение с клиентом.</li>
	<li>Реализовать возможность клиентом закрывать сообщения.</li>
	<li>Создать лог сообщений.</li>
</ol>
<hr>
<h5>Процесс реализации:</h5>
<ul>
	<li>
	<h6>Сегодня 14 января 2018</h6>
	<hr>
	<p>Сейчас 21:09. Сегодня воскресенье.</p>
	<hr>
	<p>Сегодня я реализовал первые два пункта. Приложение работает так как нужно, но есть один баг, который нужно пофиксить: когда пользователь ввел три сообщения, последующие не отправляются. Это проблема. Возможно она из-за того, что буфер переполняется. Нужно провести еше пару тестов. Может попробовать реализовать динамический буфер, но я это и так реализую. Можно поробывать изменить значение буфера. Есть еше один баг. Когда пользовтель подключился к серверу, сервер долже отправить сообщение status code 200, что означает - успешное подключение, но он это делает только после отправки первого сообщения.
	Попробовал увеличить размер буфера. Не помогло. Значит дело в другом.
	Еше почему-то выскакивают ошибки, которые не должны выскакивать, но они это делают. Причем при постаяном запуске скрипта. Но если перезагрузить терминал, то они пропадают.</p>
	</li>
	<li>
	<h6>Сегодня 15 января 2018</h6>
	<hr>
	<p>Сейчас 22:01. Сегодня понедельник.</p>
	<hr>
	<p>Сегодня я пофиксил баг. Сначал я думал, что дело все в ответе сервера status code 200. Но, когда я его убрал, клиент мог отправить серверу только одно сообщение. Дело было вот в чем. В коде клиент, после отправки сообщения он ожидает ответа. Именно ожидае. Function recv будет работать пока не получит ответ, когда она его получает, то можно работать дальше, потому что итерация бесконченого цикла закончилась, и начилась новая итерация. Да. Я отказался от stdin в пользу input. Но, когда я это сделал все опять по накатанное. Ошибка была на стороне сервера. Я закоментировал connection.send(...). Это функция, которая делает ответ. Но ответа не было. Значит функция recv ожидает ответа, которого не будет. Значит отправить сообщение не получится. Вот такие дела. Нужно провести рефакторинг завтра.</p>
	</li>
	<li>
	<h6>Сегодня 19 января 2018</h6>
	<hr>
	<p>Сейчас 17:53. Сегодня пятница.</p>
	<hr>
	<p>Нужно реализовать фичу, которая будет следить за тем, конда закроется соединение. В принципе я реализовал динамический буфер, но он не особо работаем. Ну да ладно. Он ососбо и не нужен.</p>
	</li>
	<li>
	<h6>Cегодня 31 января 2018</h6>
	<hr>
	<p>Сейчас 19:21. Сегодня среда.</p>
	<hr>
	<p>Я уже много, что реализовал. Теперь, перед созданием GUI, осталось только создать реализацию сессии.</p>
	<p>Как будет выглядеть сессия.</p>
	<ol>
		<li>Перво-на-перво должен выбрать: создать ли ему новый аккаунт или пользоваться своим старым. Если он выберит первый вариант, то ему будет предложенно создать аккаунт. Затем, если пройдет все без ошибок, то клиент зарегистрируется и может создать сессию с сервером, а если нет, то будет предложенно, что было предложенно выше. Если же он выберет войти в аккаунт, и все пройдет без ошибок, то будет созданна сессия с сервером, а если же будет ошибка, то ему будет задан тот же вопрос.</li>
		<li>Сервер может в сесси обрабатывать только одного клиента.</li>
		<li>Закрытие происходит по воли сервера или клиента.</li>
		<li>Клиент закрывает сессию при помощи комманды !close.</li>
		<li>Сервер закрывает сессию только при вызове какого-либо исключения.</li>
		<li>Сервер сам может создавать сессии.</li>
	</ol>
	</li>
	<li>
	<h6>Сегодня 4 февраля 2018</h6>
	<hr>
	<p>Сейчас 20:19.</p>
	<hr> 
	<p>
	Сегодня мне пришла идея на счет реализации ссесии. Я решил изменить структуру протокола message. В его запросе будет информация о отправители и о получателе(т.е. кто кому отправил сообщение.) Затем, я решил, что сервер будет создавать сессию у себя в процессе, а так же пытаться отправлять сообщения по мере поступления, основываясь на данных запроса. Каждое сообщение, вход или регистрацию сервер будет записывать у себя в логе и в логе у клиентов. Если же клиент не смог получить сообщение, то сервер отправить его повторно, взяв его из лога.</p>
	</li>
</ul>